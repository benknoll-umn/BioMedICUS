package edu.umn.biomedicus.acronym;

import com.sun.istack.internal.Nullable;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Represents a collection of terms (including phrases) and word embeddings for them
 * Created by gpfinley on 3/14/16.
 */
public class Embeddings implements Iterable<String>, Serializable {

    // For looking up the index based on the word
    private Map<String,Integer> dictionary;
    // For finding the word based on the index
    private List<String> terms;
    private List<WordEmbedding> vectors;

    // Word frequency (from vocab.txt file)
    private List<Integer> frequency;

    private int dimensionality;

    public Embeddings(int dimensionality) {
        this.dimensionality = dimensionality;
        dictionary = new HashMap<>();
        terms = new ArrayList<>();
        vectors = new ArrayList<>();
        frequency = new ArrayList<>();
    }

    public int dimensionality() {
        return dimensionality;
    }

    /**
     * Get the number of occurrences of this word/phrase in the data.
     * SETTING THIS IS OPTIONAL. THIS METHOD WILL RETURN -1 IF NO FREQUENCY HAS BEEN SET.
     * @param phrase the phrase to look up
     * @return the counts of that phrase
     */
    public int getFrequency(String phrase) {
        Integer wordInt = dictionary.get(phrase);
        if(wordInt == null) return 0;
        return frequency.get(dictionary.get(phrase));
    }

    public int getRank(String phrase) {
        return dictionary.get(phrase) + 1;
    }

    public void setWordFrequency(String phrase, int freq) {
        if(!dictionary.containsKey(phrase)) return;
        frequency.set(dictionary.get(phrase), freq);
    }

    public void addWordAndEmbedding(String phrase, WordEmbedding embedding) {
        if(dictionary.containsKey(phrase)) {
            return;
        }
        dictionary.put(phrase, dictionary.size());
        terms.add(phrase);
        vectors.add(embedding);
        frequency.add(-1);
    }

    public WordEmbedding get(String phrase) {
        if(!dictionary.containsKey(phrase)) return null;
        return vectors.get(dictionary.get(phrase));
    }

    public void normalizeAll() {
        for(WordEmbedding embedding : vectors)
            embedding.normalize();
    }

    public boolean contains(String phrase) {
        return dictionary.containsKey(phrase);
    }

    public int size() {
        return terms.size();
    }

    @Override
    public Iterator<String> iterator() {
        return terms.iterator();
    }

    public Iterator<WordEmbedding> embeddingIterator() {
        return vectors.iterator();
    }

    public static Embeddings readBinFile(String filename, int maxWords) throws IOException {
        Pattern underscores = Pattern.compile("_+");
        InputStream reader = new FileInputStream(filename);
        char c;
        String nWordsStr = "";
        while(true) {
            c = (char)reader.read();
            if(c==' ') break;
            nWordsStr += c;
        }
        String sizeStr = "";
        while(true) {
            c = (char)reader.read();
            if(c=='\n') break;
            sizeStr += c;
        }
        int nWords = Integer.parseInt(nWordsStr);
        if (maxWords > 0 && maxWords < nWords) {
            nWords = maxWords;
        }
        int size = Integer.parseInt(sizeStr);
        Embeddings wes = new Embeddings(size);
        char firstchar = '\n';
        byte[] bytes = new byte[size*4];
        for(int i=0; i<nWords; i++) {
            String word = "";
            if(firstchar != '\n')
                word += firstchar;
            while((c = (char)reader.read()) != ' ') {
                word += c;
            }
            // Read in all bytes associated with this vector
            reader.read(bytes, 0, size*4);
            float vector[] = new float[size];
            for(int j=0; j<size; j++) {
                vector[j] = ByteBuffer.wrap(bytes, j * 4, 4).order(ByteOrder.LITTLE_ENDIAN).getFloat();
            }
            // For some files, there's an extra \n (such as those generated by the C word2vec)
            // For others, there's no newline--it goes straight to the next word (the GoogleNews vectors, e.g.)
            firstchar = (char) reader.read();
            String newPhrase = underscores.matcher(word).replaceAll(" ").trim();
            if (newPhrase.length() > 0) {
                wes.addWordAndEmbedding(newPhrase, new WordEmbedding(vector));
            }
        }
        return wes;
    }

}

